// Copyright (c) coherence ApS.
// See the license file in the package root for more information.

namespace Coherence.Editor.Toolkit
{
    using Coherence.Toolkit;
    using System;
    using UnityEditor;
    using UnityEngine;

    internal partial class CoherenceSyncEditor
    {
        private static partial class GUIStyles
        {
            public static readonly GUIStyle authorityButton = new GUIStyle(EditorStyles.miniButton)
            {
                stretchWidth = false,
                fixedHeight = 18,
                fixedWidth = 70,
            };
        }

        private static partial class GUIContents
        {
            public static readonly GUIContent title = EditorGUIUtility.TrTextContent("Play Mode Information");
            public static readonly GUIContent help = EditorGUIUtility.TrIconContent("_Help", "Open Authority Documentation");

            public static readonly GUIContent syncDisabled = EditorGUIUtility.TrTextContentWithIcon("Entity not networked: CoherenceSync disabled.", "Info");
            public static readonly GUIContent noBridge = EditorGUIUtility.TrTextContentWithIcon("Entity not networked: CoherenceBridge not found.\nCreate a CoherenceBridge via menu item GameObject/coherence/Coherence Bridge ", "Warning");
            public static readonly GUIContent notConnected = EditorGUIUtility.TrTextContentWithIcon("Connect to display this entity's state.", "Info");
            public static readonly GUIContent usingSimulators = EditorGUIUtility.TrTextContentWithIcon("When using CoherenceInput you can request State and Input authority separately.", "Info");

            public static readonly GUIContent entity = EditorGUIUtility.TrTextContent("Entity ID", "The Entity ID associated with this CoherenceSync");
            public static readonly GUIContent uuid = EditorGUIUtility.TrTextContent("UUID", "The persistence Unique ID can be setup manually. It is autogenerated at runtime otherwise.");
            public static readonly GUIContent lod = EditorGUIUtility.TrTextContent("LOD", "The current Level of Detail of this entity");
            public static readonly GUIContent lodDisabled = EditorGUIUtility.TrTextContent("LOD", "This entity is not using Levels of Detail");
            public static readonly GUIContent lodNone = EditorGUIUtility.TrTextContent("(none)");

            public static readonly GUIContent authority = Icons.GetContentWithText("Coherence.Hierarchy.Networked", "Authority", "Authority defines which Client or Simulation Server is allowed to make changes to an Entity. An Entity is any networked GameObject.");
            public static readonly GUIContent authorityWithIcon = Icons.GetContentWithText("Coherence.Hierarchy.Simulated", "Authority", "Authority defines which Client or Simulation Server is allowed to make changes to an Entity. An Entity is any networked GameObject");
            public static readonly GUIContent authorityYes = EditorGUIUtility.TrTextContent("Yes", "You have authority over this entity");
            public static readonly GUIContent authorityNo = EditorGUIUtility.TrTextContent("No", "You don't have authority over this entity");
            public static readonly GUIContent inputAuthority = Icons.GetContentWithText("Coherence.Input.Remote", "Input Authority", "The control you have over the inputs of this entity");
            public static readonly GUIContent inputAuthorityWithIcon = Icons.GetContentWithText("Coherence.Input", "Input Authority", "The control you have over the inputs of this entity");
            public static readonly GUIContent stateAuthority = Icons.GetContentWithText("Coherence.Hierarchy.Networked", "State Authority", "The control you have over the state of this entity");
            public static readonly GUIContent stateAuthorityWithIcon = Icons.GetContentWithText("Coherence.Hierarchy.Simulated", "State Authority", "The control you have over the state of this entity");
            public static readonly GUIContent abandonAuthority = EditorGUIUtility.TrTextContent("Abandon", "An abandoned entity is transferred to the RS, becoming orphaned. Clients are able to request authority over this entity.\n\nThis entity is set to auto-adopt, meaning clients will try to get authority over this entity once it has become orphaned");
            public static readonly GUIContent requestInputAuthority = EditorGUIUtility.TrTextContent("Request", "Authority transfer may be requested, but it may be rejected by the current authority");
            public static readonly GUIContent requestStateAuthority = EditorGUIUtility.TrTextContent("Request", "Authority transfer may be requested, but it may be rejected by the current authority");
            public static readonly GUIContent requestFullAuthority = EditorGUIUtility.TrTextContent("Request", "Authority transfer may be requested, but it may be rejected by the current authority");
            public static readonly GUIContent adopt = EditorGUIUtility.TrTextContent("Adopt", "Adopting Entity will alter your Authority request");
        }

        internal void DrawPlaymode()
        {
            DrawTitleBar();

            if (!sync.isActiveAndEnabled)
            {
                EditorGUILayout.HelpBox(GUIContents.syncDisabled);
                return;
            }

            if (sync.CoherenceBridge == null)
            {
                EditorGUILayout.HelpBox(GUIContents.noBridge);
                return;
            }

            if (!sync.CoherenceBridge.IsConnected)
            {
                EditorGUILayout.HelpBox(GUIContents.notConnected);
                return;
            }

            EditorGUILayout.BeginVertical(GUI.skin.box);

            DrawAuthority();
            EditorGUILayout.Space();

            // TODO cache strings to reduce allocs
            EditorGUILayout.LabelField(GUIContents.entity, EditorGUIUtility.TrTempContent(sync.EntityState.EntityID.ToString()));
            EditorGUILayout.LabelField(GUIContents.uuid, EditorGUIUtility.TrTempContent(sync.EntityState.CoherenceUUID.ToString()));

            if (sync.UsesLODsAtRuntime)
            {
                EditorGUILayout.LabelField(GUIContents.lod, EditorGUIUtility.TrTempContent(sync.Archetype.LastObservedLodLevel.ToString()));
            }
            else
            {
                EditorGUI.BeginDisabledGroup(true);
                EditorGUILayout.LabelField(GUIContents.lodDisabled, GUIContents.lodNone);
                EditorGUI.EndDisabledGroup();
            }

            EditorGUILayout.EndVertical();
        }

        private void DrawTitleBar()
        {
            GUILayout.BeginHorizontal();
            EditorGUILayout.LabelField(GUIContents.title);
            if (GUILayout.Button(GUIContents.help, EditorStyles.label, GUILayout.ExpandWidth(false)))
            {
                Application.OpenURL(DocumentationLinks.GetDocsUrl(DocumentationKeys.Authority));
            }
            GUILayout.EndHorizontal();
        }

        private void RequestAuthority(AuthorityType authorityType)
        {
            if (!sync.RequestAuthority(authorityType))
            {
                var window = EditorWindow.focusedWindow;
                if (window)
                {
                    window.ShowNotification(new GUIContent($"Failed to request authority of type '{authorityType}'"));
                }
            }
        }

        private void DrawAuthority()
        {
            if (sync.simulationType == CoherenceSync.SimulationType.ClientSide)
            {
                DrawAuthorityField(
                    sync.HasStateAuthority ? GUIContents.authorityWithIcon : GUIContents.authority,
                    sync.HasStateAuthority ? GUIContents.authorityYes : GUIContents.authorityNo,
                    !sync.HasStateAuthority && !sync.EntityState.IsOrphaned,
                    GUIContents.requestFullAuthority,
                    () => RequestAuthority(AuthorityType.Full)
                );
            }
            else
            {
                EditorGUILayout.HelpBox(GUIContents.usingSimulators);
                EditorGUILayout.Space();

                DrawAuthorityField(
                    sync.HasStateAuthority ? GUIContents.stateAuthorityWithIcon : GUIContents.stateAuthority,
                    sync.HasStateAuthority ? GUIContents.authorityYes : GUIContents.authorityNo,
                    !sync.HasStateAuthority && !sync.EntityState.IsOrphaned,
                    GUIContents.requestStateAuthority,
                    () => RequestAuthority(AuthorityType.State)
                );

                DrawAuthorityField(
                    sync.HasInputAuthority ? GUIContents.inputAuthorityWithIcon : GUIContents.inputAuthority,
                    sync.HasInputAuthority ? GUIContents.authorityYes : GUIContents.authorityNo,
                    !sync.HasInputAuthority && !sync.EntityState.IsOrphaned,
                    GUIContents.requestInputAuthority,
                    () => RequestAuthority(AuthorityType.Input)
                );
            }

            EditorGUILayout.BeginHorizontal();
            EditorGUILayout.Space();

            if (sync.EntityState.IsOrphaned)
            {
                if (GUILayout.Button(GUIContents.adopt, GUIStyles.authorityButton))
                {
                    sync.Adopt();
                }
            }
            else
            {
                var canAbandon = !sync.EntityState.IsOrphaned &&
                    sync.IsPersistent &&
                    sync.authorityTransferType != CoherenceSync.AuthorityTransferType.NotTransferable;

                EditorGUI.BeginDisabledGroup(!canAbandon);
                if (GUILayout.Button(GUIContents.abandonAuthority, GUIStyles.authorityButton))
                {
                    sync.AbandonAuthority();
                }
                EditorGUI.EndDisabledGroup();
            }

            EditorGUILayout.EndHorizontal();
        }

        private void DrawAuthorityField(GUIContent authorityLabel, GUIContent valueLabel, bool buttonEnabled, GUIContent buttonContent, Action buttonAction)
        {
            EditorGUILayout.BeginHorizontal();

            EditorGUILayout.LabelField(authorityLabel, valueLabel, GUILayout.ExpandWidth(false));

            EditorGUILayout.Space();

            EditorGUI.BeginDisabledGroup(!buttonEnabled);
            if (GUILayout.Button(buttonContent, GUIStyles.authorityButton))
            {
                buttonAction();
            }
            EditorGUI.EndDisabledGroup();

            EditorGUILayout.EndHorizontal();
        }
    }
}
